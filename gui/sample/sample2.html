<!-- Add WebGLRenderingContext.texSubImage2D -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>WebGL Framebuffer (JSDoc)</title>

    <style>
      body {
        margin: 0;
        background: #111;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }

      #container {
        width: 90vw;
        height: 90vh;
      }

      canvas {
        display: block;
        image-rendering: pixelated;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <canvas id="canvas"></canvas>
    </div>

    <script>
      (() => {
        /**
         * Width of the emulated framebuffer.
         * Nintendo DS screen width.
         * @constant {number}
         */
        const FB_WIDTH = 256;

        /**
         * Height of the emulated framebuffer.
         * Top screen (192) + bottom screen (192).
         * @constant {number}
         */
        const FB_HEIGHT = 384;

        /**
         * Container element used to calculate display size.
         * @type {HTMLElement}
         */
        const container = document.getElementById("container");

        /**
         * Canvas element where the framebuffer is presented.
         * @type {HTMLCanvasElement}
         */
        const canvas = document.getElementById("canvas");

        /**
         * WebGL rendering context.
         * Used only for scaling and presenting the framebuffer.
         * @type {WebGLRenderingContext}
         */
        const gl = canvas.getContext("webgl", {
          alpha: false,
          depth: false,
          stencil: false,
          antialias: false,
          powerPreference: "low-power",
        });

        if (!gl) {
          throw new Error("Failed to create WebGL context");
        }

        /* ============================================================
        Shader sources
        ============================================================ */

        /**
         * Vertex shader.
         * Renders a fullscreen quad.
         * Converts clip-space positions to UV coordinates.
         * @type {string}
         */
        const VERT_SRC = `
    attribute vec2 a_pos;
    varying vec2 v_uv;

    void main() {
      v_uv = a_pos * 0.5 + 0.5;
      gl_Position = vec4(a_pos, 0.0, 1.0);
    }
  `;

        /**
         * Fragment shader.
         * Samples the framebuffer texture and outputs it directly.
         * @type {string}
         */
        const FRAG_SRC = `
    precision mediump float;
    varying vec2 v_uv;
    uniform sampler2D u_tex;

    void main() {
      gl_FragColor = texture2D(u_tex, v_uv);
    }
  `;

        /**
         * Compile a WebGL shader.
         * @param {number} type - gl.VERTEX_SHADER or gl.FRAGMENT_SHADER
         * @param {string} source - GLSL source code
         * @returns {WebGLShader}
         */
        function compileShader(type, source) {
          const shader = gl.createShader(type);
          gl.shaderSource(shader, source);
          gl.compileShader(shader);

          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw new Error(gl.getShaderInfoLog(shader));
          }
          return shader;
        }

        /**
         * Create and link a WebGL program.
         * @param {string} vsSource - Vertex shader source
         * @param {string} fsSource - Fragment shader source
         * @returns {WebGLProgram}
         */
        function createProgram(vsSource, fsSource) {
          const vs = compileShader(gl.VERTEX_SHADER, vsSource);
          const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);
          const program = gl.createProgram();
          gl.attachShader(program, vs);
          gl.attachShader(program, fs);
          gl.linkProgram(program);

          if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error(gl.getProgramInfoLog(program));
          }
          return program;
        }

        /**
         * WebGL program used to render the framebuffer.
         * @type {WebGLProgram}
         */
        const program = createProgram(VERT_SRC, FRAG_SRC);
        gl.useProgram(program);

        /* ============================================================
     Fullscreen quad setup
     ============================================================ */

        /**
         * Attribute location for quad positions.
         * @type {number}
         */
        const posLoc = gl.getAttribLocation(program, "a_pos");

        /**
         * Vertex buffer for a fullscreen quad.
         * @type {WebGLBuffer}
         */
        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
          gl.STATIC_DRAW,
        );

        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        /* ============================================================
     Framebuffer texture
     ============================================================ */

        /**
         * Texture that represents the emulated framebuffer.
         * Each texel corresponds to one RGBA pixel.
         * @type {WebGLTexture}
         */
        const fbTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, fbTexture);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        /**
         * Allocate texture storage.
         * This is equivalent to allocating VRAM for the final screen.
         */
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          FB_WIDTH,
          FB_HEIGHT,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          null,
        );

        /* ============================================================
     Emulated GPU output buffer
     ============================================================ */

        /**
         * CPU-side framebuffer.
         * This simulates the final output of the emulator GPU.
         * Layout:
         *   index + 0: Red
         *   index + 1: Green
         *   index + 2: Blue
         *   index + 3: Alpha
         * @type {Uint8Array}
         */
        const framebuffer = new Uint8Array(FB_WIDTH * FB_HEIGHT * 4);

        /**
         * Used only to animate dummy data.
         * @type {number}
         */
        let frameCounter = 0;

        /**
         * Write dummy pixel data into the framebuffer.
         * In a real emulator, this would be produced by the PPU / GPU.
         */
        function writeDummyFrame() {
          for (let y = 0; y < FB_HEIGHT; y++) {
            for (let x = 0; x < FB_WIDTH; x++) {
              const index = (y * FB_WIDTH + x) * 4;
              const isTopScreen = y < 192;

              framebuffer[index + 0] = isTopScreen
                ? (x + frameCounter) & 255
                : 40;
              framebuffer[index + 1] = isTopScreen
                ? 40
                : (y + frameCounter) & 255;
              framebuffer[index + 2] = isTopScreen ? 80 : 200;
              framebuffer[index + 3] = 255;
            }
          }
          frameCounter++;
        }

        /* ============================================================
     Resize & render
     ============================================================ */

        /**
         * Resize canvas and update viewport.
         * Keeps the correct framebuffer aspect ratio.
         */
        function resize() {
          const cw = container.clientWidth;
          const ch = container.clientHeight;
          const aspect = FB_WIDTH / FB_HEIGHT;

          let w = Math.min(cw, ch * aspect);
          let h = w / aspect;

          const dpr = window.devicePixelRatio || 1;
          canvas.width = Math.floor(w * dpr);
          canvas.height = Math.floor(h * dpr);
          canvas.style.width = w + "px";
          canvas.style.height = h + "px";

          gl.viewport(0, 0, canvas.width, canvas.height);
        }

        /**
         * Render one frame.
         * Uploads the framebuffer using texSubImage2D.
         */
        function render() {
          resize();

          writeDummyFrame();

          gl.bindTexture(gl.TEXTURE_2D, fbTexture);
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            FB_WIDTH,
            FB_HEIGHT,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            framebuffer,
          );

          gl.clearColor(0, 0, 0, 1);
          gl.clear(gl.COLOR_BUFFER_BIT);

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

          requestAnimationFrame(render);
        }

        render();
      })();
    </script>
  </body>
</html>
