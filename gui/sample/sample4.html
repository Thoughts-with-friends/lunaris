<!-- Canvas to draw image file -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Drag & Drop WebGL</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      #dropzone {
        position: absolute;
        top: 10px;
        left: 10px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.5);
        color: white;
        z-index: 10;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <div id="dropzone">Drop JPG/PNG here</div>
    <canvas id="glcanvas"></canvas>

    <script>
      /**
       * Vertex shader: full screen quad
       */
      const VERT_SRC = /* glsl */ `
        attribute vec2 a_pos;
        varying vec2 v_uv;
        void main() {
            v_uv = a_pos * 0.5 + 0.5;
            gl_Position = vec4(a_pos, 0.0, 1.0);
        }`;

      /**
       * Fragment shader: mouse-interactive color effect
       */
      const FRAG_SRC = /* glsl */ `
        precision mediump float;
        uniform vec2 u_mouse;
        uniform float u_time;
        varying vec2 v_uv;
        void main() {
            float dist = distance(v_uv, u_mouse);
            float wave = 0.5 + 0.5 * sin(u_time * 3.0 + dist * 10.0);
            gl_FragColor = vec4(v_uv.x*wave, v_uv.y*wave, wave, 1.0);
        }`;

      /** @type {HTMLCanvasElement} */
      const canvas = document.getElementById("glcanvas");
      /** @type {WebGLRenderingContext} */
      const gl = canvas.getContext("webgl");
      if (!gl) alert("WebGL not supported");

      // Compile shader helper
      function compileShader(type, src) {
        const sh = gl.createShader(type);
        gl.shaderSource(sh, src);
        gl.compileShader(sh);
        if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
          throw new Error(gl.getShaderInfoLog(sh));
        }
        return sh;
      }

      // Create program helper
      function createProgram(vs, fs) {
        const p = gl.createProgram();
        gl.attachShader(p, vs);
        gl.attachShader(p, fs);
        gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
          throw new Error(gl.getProgramInfoLog(p));
        }
        return p;
      }

      // Compile/link GLSL
      const vertShader = compileShader(gl.VERTEX_SHADER, VERT_SRC);
      const fragShader = compileShader(gl.FRAGMENT_SHADER, FRAG_SRC);
      const program = createProgram(vertShader, fragShader);

      // Quad setup
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
        gl.STATIC_DRAW,
      );

      const aPos = gl.getAttribLocation(program, "a_pos");
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

      // Uniforms
      const uMouse = gl.getUniformLocation(program, "u_mouse");
      const uTime = gl.getUniformLocation(program, "u_time");

      // Mouse/touch
      let mouseX = 0.5,
        mouseY = 0.5;
      canvas.addEventListener("mousemove", (e) => {
        const r = canvas.getBoundingClientRect();
        mouseX = (e.clientX - r.left) / r.width;
        mouseY = 1.0 - (e.clientY - r.top) / r.height;
      });
      canvas.addEventListener(
        "touchmove",
        (e) => {
          const r = canvas.getBoundingClientRect();
          const t = e.touches[0];
          mouseX = (t.clientX - r.left) / r.width;
          mouseY = 1.0 - (t.clientY - r.top) / r.height;
          e.preventDefault();
        },
        { passive: false },
      );

      // ===== Drop image handling =====
      let droppedTexture = null;
      let useTexture = false;

      /**
       * Create WebGL texture from image
       * @param {HTMLImageElement} img
       */
      function createTextureFromImage(img) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true); // flip Y
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          img,
        );
        return tex;
      }

      // Handle file drop
      const dropzone = document.getElementById("dropzone");
      canvas.addEventListener("dragover", (e) => e.preventDefault());
      canvas.addEventListener("drop", (e) => {
        e.preventDefault();
        const file = e.dataTransfer.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          const img = new Image();
          img.onload = () => {
            droppedTexture = createTextureFromImage(img);
            useTexture = true;
          };
          img.src = ev.target.result;
        };
        reader.readAsDataURL(file);
      });

      // Draw image with simple texture shader
      function drawTexture(tex) {
        if (!tex) return;

        const texFrag = `
        precision mediump float;
        varying vec2 v_uv;
        uniform sampler2D u_tex;
        void main(){ gl_FragColor = texture2D(u_tex, v_uv); }
        // void main(){ gl_FragColor = texture2D(u_tex, vec2(v_uv.x, 1.0 - v_uv.y)); }
    `;
        const frag = compileShader(gl.FRAGMENT_SHADER, texFrag);
        const progTex = createProgram(vertShader, frag);
        gl.useProgram(progTex);

        const posLoc = gl.getAttribLocation(progTex, "a_pos");
        gl.enableVertexAttribArray(posLoc);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        const uTex = gl.getUniformLocation(progTex, "u_tex");
        gl.uniform1i(uTex, 0);

        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }

      // ===== Animation loop =====
      function frame(time) {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT);

        if (useTexture) {
          drawTexture(droppedTexture);
        } else {
          gl.useProgram(program);
          gl.uniform2f(uMouse, mouseX, mouseY);
          gl.uniform1f(uTime, time * 0.001);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        requestAnimationFrame(frame);
      }

      requestAnimationFrame(frame);
    </script>
  </body>
</html>
