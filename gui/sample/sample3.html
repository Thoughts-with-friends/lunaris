<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>GLSL Interactive Demo with JSDoc</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <canvas id="glcanvas"></canvas>

    <script>
      // ===== Vertex Shader =====
      /** @type {string} Vertex shader source code */
      const VERT_SRC = `
        attribute vec2 a_pos;
        varying vec2 v_uv;
        void main() {
            v_uv = a_pos * 0.5 + 0.5;
            gl_Position = vec4(a_pos, 0.0, 1.0);
      }`;

      // ===== Fragment Shader =====
      /** @type {string} Fragment shader source code */
      const FRAG_SRC = `
        precision mediump float;
        uniform vec2 u_mouse;
        uniform float u_time;
        varying vec2 v_uv;
        void main() {
            float dist = distance(v_uv, u_mouse);
            float wave = 0.5 + 0.5 * sin(u_time * 3.0 + dist * 10.0);
            gl_FragColor = vec4(v_uv.x * wave, v_uv.y * wave, wave, 1.0);
        }`;

      // ===== WebGL Setup =====
      /** @type {HTMLCanvasElement} */
      const canvas = /** @type {HTMLCanvasElement} */ (
        document.getElementById("glcanvas")
      );
      /** @type {WebGLRenderingContext} */
      const gl = /** @type {WebGLRenderingContext} */ (
        canvas.getContext("webgl")
      );
      if (!gl) alert("WebGL not supported");

      /**
       * Compile a shader.
       * @param {number} type Shader type (gl.VERTEX_SHADER or gl.FRAGMENT_SHADER)
       * @param {string} src GLSL source code
       * @returns {WebGLShader}
       */
      function compileShader(type, src) {
        const sh = gl.createShader(type);
        gl.shaderSource(sh, src);
        gl.compileShader(sh);
        if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
          throw new Error(gl.getShaderInfoLog(sh));
        }
        return sh;
      }

      const vertShader = compileShader(gl.VERTEX_SHADER, VERT_SRC);
      const fragShader = compileShader(gl.FRAGMENT_SHADER, FRAG_SRC);

      /**
       * Create and link a WebGL program.
       * @param {WebGLShader} vs Vertex shader
       * @param {WebGLShader} fs Fragment shader
       * @returns {WebGLProgram}
       */
      function createProgram(vs, fs) {
        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          throw new Error(gl.getProgramInfoLog(program));
        }
        return program;
      }

      const program = createProgram(vertShader, fragShader);
      gl.useProgram(program);

      // Full screen quad
      /** @type {WebGLBuffer} */
      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
        gl.STATIC_DRAW,
      );

      /** @type {number} Attribute location of vertex positions */
      const aPos = gl.getAttribLocation(program, "a_pos");
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

      // Uniform locations
      /** @type {WebGLUniformLocation} */
      const uMouse = gl.getUniformLocation(program, "u_mouse");
      /** @type {WebGLUniformLocation} */
      const uTime = gl.getUniformLocation(program, "u_time");

      // Mouse tracking
      /** @type {number} Normalized mouse X [0,1] */
      let mouseX = 0.5;
      /** @type {number} Normalized mouse Y [0,1] */
      let mouseY = 0.5;

      /**
       * Update mouse position and convert to [0,1] range.
       * @param {MouseEvent} e
       */
      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = (e.clientX - rect.left) / rect.width;
        mouseY = 1.0 - (e.clientY - rect.top) / rect.height;
      });

      /**
       * Render a frame.
       * @param {number} time Current timestamp in milliseconds
       */
      function frame(time) {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);

        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform2f(uMouse, mouseX, mouseY);
        gl.uniform1f(uTime, time * 0.001);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(frame);
      }

      // Start animation
      requestAnimationFrame(frame);
    </script>
  </body>
</html>
